---
title: '📝 Next.js : 노마드코더 - NextJS 시작하기'
date: '2024-04-25'
lastmod: '2024-04-25'
tags: ['nextjs']
draft: false
summary: 'Next.js는 React 기반의 프레임워크로, 서버사이드 렌더링과 정적 사이트 생성을 지원한다.'
images: []
---

## ▶ 1강

### ✅ react.js 와 next.js의 차이

- react.js : 라이브러리(내가 사용하는 것)
- next.js : 프레임워크(우리가 규칙을 지켜야함, 주도권 없음)

### ✅ Project setting

- npm init -y : package.json 설치됨
- package.json의 "lisence"값 "MIT"로 변경
- npm install react@latest next@latest react-dom@latest
- "dev" script를 만들고 "next dev" 명령어 지정
- app폴더에 page.tsx 생성 (꼭!! app과 page)
- npm run dev로 실행

## ▶ 2강

### ✅ Defining Routes

- app 폴더 안에 만들고 싶은 페이지 폴더를 만들고 page.tsx 파일을 만들면 자동으로 경로가 된다.
  ex) app/login/page.tsx ---> http://localhost:3000/login
- 사용자가 url로부터 보게 될 요소는 page.tsx

### ✅ Not Found

- app/not-found.tsx : 잘못된 url를 입력했을 때 보여준다.

### ✅ Link

- `import Link from "next/link"`
- 클릭하면 페이지 이동
- ex) `<Link href="/">Home</Link>`

### ✅ usePathname

- `import { usePathname } from "next/navigation";`
- 현재 경로명을 알려준다.
- client component hook : 사용 파일에 "use client" 써줘야한다.

### ✅ SSR VS CSR

- rendering 의미 : javascript function을 가져와서 브라우저가 이해할 수 있는 HTML로 변환하는 작업을 말한다.
- CSR : client side rendering
  - 모든 rendering, 즉 모든 UI 구축 작업이 모두 client 측에서 발생
  - client는 javascript를 로드하고, 그 후에 javascript가 UI를 빌드
- SSR : server side rendering
  - javascript가 활성화되어있지 않아도 사용자가 HTML을 볼 수 있다.
  - 모든 컴포넌트와 페이지들은 먼저 backend에서 render.

### ✅ Hydration

- 단순 HTML을 React application으로 초기화하는 작업.
- 사용자가 페이지에 접속을 시도하면, backend에서 생성된 단순 HTML을 넘겨주고 뒷단에서 React application을 초기화(HTML을 interacitve하게 만들기 위해서)

### ✅ "use client"

- hydrate가 필요한 component에 "use client"를 써줘야한다.
- 즉, "use client"를 써준 component는 backend에서 render 되고, frontend에서 hydrate된다.
- server component 안에 client componet는 가질 수 있지만 그 반대는 불가.

### ✅ Layouts

- NextJS는 root layout을 적용하고 url을 확인해 해당 폴더로 가서 layout이 있다면 적용한다.
- 중첩 가능

### ✅ Route group

- 루트 레이아웃을 사용하지 않고 여러 레이아웃을 사용하게 할 수 있다.
- 레이아웃 중에서 선택하거나 선택 해제하여 사용할 수 있다.
- (폴더 이름) 과 같이 폴더 이름을 괄호로 묶어준다. -> url에서 보이지 않는다.

\*\* 활용할 수 있는 방법이 많은 것 같다. 찾아봐야겠다.

### ✅ Metadata

- HTML head 엘리먼트 내의 meta 태그 정의
- layout과 page만 export한다.
- 다른 metadata들과 병합된다.
- 아래와 같이 template을 지정할 수 있다.

```javascript
export const metadata = {
  title: {
    template: '%s | Next Movies',
    default: 'Loading...',
  },
  description: 'Generated by Next.js',
}
```

🔗[공식문서 : metadata](https://nextjs.org/docs/app/building-your-application/optimizing/metadata)

### ✅ Dynamic Routes

- 정적인 경로가 아닌 동적인 경로
- [폴더이름] 과 같이 대괄호를 써서 생성한다.
- 사용 예시 : [id] 인 경우

```javascript
export default function MovieDetail({ params: { id } }) {
  return <h1>Movie {id}</h1>
}
```

## ▶ 3강

### ✅ Data Fetch

- 데이터를 fetch하는 코드 작성
- server component에 넣기 (사용자에게 전달 x, dev tool에서 보이지 않음)
- 해당 컴포넌트는 async

### ✅ Loading

- loading.tsx
- server component가 fetch하는 중에 loading 파일을 제공해주면 페이지에 나타난다.
- await가 끝나면 loading component를 await된 component로 바꿔준다.

### ✅ Parallel Requests

- Promise.all 사용

```javascript
const [movie, videos] = await Promise.all([getMovie(id), getVideos(id)])
```

- movie-info파일과 movie-videos파일을 만들어 각각 개별적으로 기다리게 한다.

### ✅ Suspense

- MovieInfo와 MovieVideos는 async component이기 때문에 suspense component로 감싸줘야한다.
- Suspense component의 fallback prop : component가 await되는 동안 표시할 메세지를 render할 수 있게 해준다.

### ✅ Error Handling

- error.tsx : 오류가 발생할 경우 해당 페이지를 보여준다.
- "use client"
- 같은 레벨의 페이지에서 발생하는 에러에만 작동한다.

## ▶ 4강

### ✅ CSS Modules

- 파일 이름 : 이름.module.css
- 고유한 클래스 이름을 자동으로 생성

### ✅ Dynamic Metadata

- generateMetadata 함수 사용

```typescript
export async function geberateMetadata({ params: { id } }: IParmas) {
  const movie = await getMovie(id)
  return {
    title: movie.title,
  }
}
```

### ✅ prefetch

- Link 컴포넌트가 사용자의 뷰포트에 들어갈 때 발생
- 연결된 경로의 데이터를 백그라운드에서 prefetch 및 load
- production에서만 활성화
