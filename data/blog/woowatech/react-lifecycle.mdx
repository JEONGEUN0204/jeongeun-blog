---
title: '[우아한테크코스 테코톡] React 컴포넌트 LifeCycle'
date: '2025-03-30'
lastmod: '2025-03-30'
tags: ['react']
draft: false
summary: 'React 함수형 컴포넌트의 생명주기를 useEffect와 함께 이해한다.'
images: []
---

> [[10분 테코톡] 마루의 리액트 컴포넌트 LIFECYCLE](https://www.youtube.com/watch?v=wLPHtaSfCmU)

### 리액트의 렌더링

- 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정 (컴포넌트 호출)
- 렌더링 프로세스 = 렌더 단계(컴포넌트 호출 & 변경사항 계산) + 커밋 단계(렌더 단계의 변경 사항을 실제 DOM에 적용)

### 컴포넌트의 생명주기

- #### 마운트 시점 (최초 렌더링)

1. Run lazy initializers
2. Render
3. React updates DOM
4. Run LayoutEffects
5. Browser paints screen
6. Run Effects

- #### 업데이트 시점 (리렌더링)

1. Render
2. React updates DOM
3. Cleanup LayoutEffects
4. Run LayoutEffects
5. Browser paints screen
6. Cleanup Effects
7. Run Effects

- #### 언마운트 시점 (컴포넌트 제거)

1. Run LayoutEffects
2. Cleanup Effects

### Run lazy initializers

**lazy initializers** 로 초기화 된 state는 컴포넌트가 마운트 될 때만 실행

### Render

함수 컴포넌트 내부 코드 실행 & 가상 DOM에 발생할 변경 사항 기록 (렌더 단계)

### React updates DOM

render 에서 기록된 변경사항들을 가상 DOM에 적용 (커밋 단계)

### Cleanup LayoutEffects

useLayoutEffect에 전달된 정리함수 호출

### Run LayoutEffects

useLayoutEffect 실행 (커밋 단계 이후, 브라우저 렌더링 이전)

### Browser paints screen

가상 DOM에 발생한 변경 사항을 브라우저 DOM에 적용(브라우저 렌더링), 페인팅이 끝나면 사용자는 화면에 컴포넌트가 그려진 것을 볼 수 있음

### Cleanup Effects

useEffect에 전달된 정리함수 호출

### Run Effects

useEffect 실행, 보통 이때 서버에 API 요청을 통해 데이터 불러옴

### useEffect

- dependencies에 effect에서 읽은 모든 반응형 값이 포함되어야함.
- 컴포넌트 내부에 존재하는 2가지 유형 로직
  - 렌더링 코드 : 컴포넌트의 최상단에 위치하며, 결과만 계산하는 순수함수여야함
  - 이벤트 핸들러 : 사용자와 상호작용으로 인해 발생한느 부수 효과 포함
- 렌더링을 위해 데이터를 변환하는데 Effect 필요 없음
- props가 변경될 때 일부 state를 바꿀 때 Effect 필요 없음

```javascript
// ❗ useEffect 사용할 필요 없음
const List = ({ items }) => {
  const [test, setTest] = useState(fasle)

  useEffect(() => {
    setTest(true)
  }, [items])
}
```

```javascript
// ✔
const List = ({ items }) => {
  const [prevItems, setPrevItems] = useState(items)
  const [test, setTest] = useState(fasle)

  if (items !== prevItems) {
    setPrevItems(items)
    setTest(true)
  }
}
```

### useLayoutEffect

- useLayoutEffect의 실행이 종료될 때까지 기다린 다음 브라우저 렌더링 수행하기 때문에 성능 문제 발생 가능
- DOM은 계산됐지만 이것이 화면에 반영되기 전에 필요한 작업이 있을 때 사용(useEffect 보다 자연스러운 UX 제공)
  - 특정 요소에 따라 DOM 요소를 기반으로 한 애니메이션
    - 스크롤 위치 제어
